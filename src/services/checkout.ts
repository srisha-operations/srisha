import { supabase } from "@/lib/supabaseClient";

export interface OrderPayload {
  customer_name: string;
  customer_email: string;
  customer_phone: string;
  shipping_address: any; // JSON
  total_amount: number;
  is_preorder?: boolean;
}

export interface OrderItem {
  product_id: string;
  variant_id?: string | null;
  quantity: number;
  unit_price: number;
  metadata?: any; // e.g., { size: "M", color: "red" }
}

/**
 * Create order and order_items in a single transaction-like flow.
 * Order number is generated by the database using a global sequence (order_number_seq).
 * Frontend does NOT generate order_number to avoid collisions and race conditions.
 * Sets payment_status = 'INITIATED' for backend payment processing.
 * Frontend must call initiatePayment() to trigger payment intent creation.
 */
export const createOrder = async (
  payload: OrderPayload,
  items: OrderItem[],
  userId?: string | null
): Promise<{ orderId: string; orderNumber: string }> => {
  try {
    // Do NOT generate order_number on client
    // Database will auto-generate it using order_number_seq
    const insertObj: any = {
      customer_name: payload.customer_name,
      customer_email: payload.customer_email,
      customer_phone: payload.customer_phone,
      shipping_address: payload.shipping_address,
      total_amount: payload.total_amount,
      is_preorder: payload.is_preorder || false,
      order_status: "PENDING",
      // For non-preorder, set initial payment state
      payment_status: payload.is_preorder ? null : "INITIATED",
      // â­ IMPORTANT: Do NOT set order_number - let database generate it
    };

    if (userId) insertObj.user_id = userId;

    let orderData: any = null;

    try {
      // Insert WITHOUT order_number - database will generate it
      // Read back both id AND order_number from the insert response
      const res = await supabase
        .from("orders")
        .insert(insertObj)
        .select("id, order_number")
        .single();
      
      if (res.error) throw res.error;
      orderData = res.data;
    } catch (errPrimary) {
      // Check if error is duplicate key on order_number
      // This should no longer occur since order_number is generated by database sequence
      // But keep handling for robustness
      const errorMsg = (errPrimary as any)?.message || "";
      const isDuplicateKeyError = 
        (errPrimary as any)?.code === "23505" || 
        errorMsg.includes("duplicate key");

      if (isDuplicateKeyError) {
        // This should not happen with database-generated order_number
        // But if it does, we cannot recover without knowing which order is ours
        // Fail loudly so we can investigate
        console.error("Unexpected duplicate key error with database-generated order_number:", errPrimary);
        throw new Error("Order creation failed: database-generated order_number caused collision (unexpected)");
      } else {
        // Not a duplicate key error - try fallback insert with minimal fields
        console.warn("Primary order insert failed, attempting fallback:", errPrimary);
        const fallback = {
          order_status: "PENDING",
          total_amount: payload.total_amount ?? 0,
          // Do NOT include order_number - let database generate it
        } as any;
        if (userId) fallback.user_id = userId;
        // For non-preorder, set payment_status
        if (!payload.is_preorder) {
          (fallback as any).payment_status = "INITIATED";
        }

        const res2 = await supabase
          .from("orders")
          .insert(fallback)
          .select("id, order_number")
          .single();
        
        if (res2.error) {
          throw new Error(`Failed to create order (fallback): ${res2.error.message}`);
        }
        orderData = res2.data;
      }
    }

    if (!orderData?.id) throw new Error("Order insert did not return id");
    if (!orderData?.order_number) throw new Error("Order insert did not return order_number");

    const orderId = orderData.id;
    const orderNumber = orderData.order_number;

    // Insert order items
    const itemsToInsert = items.map((item) => ({
      order_id: orderId,
      product_id: item.product_id,
      variant_id: item.variant_id || null,
      quantity: item.quantity,
      unit_price: item.unit_price,
      metadata: item.metadata || null,
    }));

    const { error: itemsError } = await supabase.from("order_items").insert(itemsToInsert);

    if (itemsError) {
      throw new Error(`Failed to create order items: ${itemsError.message}`);
    }

    return { orderId, orderNumber };
  } catch (e) {
    console.error("createOrder error:", e);
    throw e;
  }
};

/**
 * Create preorder (is_preorder=true)
 */
export const createPreorder = async (
  payload: OrderPayload,
  items: OrderItem[]
  , userId?: string | null
): Promise<{ orderId: string; orderNumber: string }> => {
  return createOrder(
    { ...payload, is_preorder: true },
    items,
    userId
  );
};

/**
 * Get shop mode from site_content
 */
export const getShopMode = async (): Promise<"normal" | "preorder"> => {
  try {
    const { data, error } = await supabase
      .from("site_content")
      .select("value")
      .eq("key", "shop_settings")
      .single();

    if (error || !data?.value) {
      return "normal"; // default
    }

    const mode = data.value?.mode || "normal";
    return mode === "preorder" ? "preorder" : "normal";
  } catch (e) {
    console.error("getShopMode error:", e);
    return "normal";
  }
};
